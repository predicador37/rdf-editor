\chapter{Diseño}

Un diseño cuidadoso puede suponer un gran ahorro a la hora de llevar a cabo el mantenimiento de una aplicación software. Son, por tanto, labores que requieren de un estudio exhaustivo y que pueden concretarse de lo general a lo particular, a medida que se avanza en el desarrollo. En las siguientes secciones se describe la arquitectura del sistema desde el punto de vista semántico y de frontend web.

\section{Arquitectura de una aplicación semántica}

Independientemente de la tecnología elegida para su implementación, una aplicación semántica genérica se caracteriza por una arquitectura concreta que se va a proceder a detallar. Dicha arquitectura está basada en componentes que pueden ser proporcionados por uno o varios productos de mercado. Es común encontrar los siguientes:

\begin{itemize}  
	\item \textbf{Almacén de ternas} (\textit{store}): no es más que una base de datos que permite el almacenamiento y extracción de ternas RDF, así como consolidar información procedente de distintas fuentes de datos.
	\item \textbf{Procesador/Serializador} (\textit{parser/serializer}): un procesador RDF lee ficheros de texto y los interpreta como ternas RDF; un serializador realiza el proceso inverso.
	\item \textbf{Motor de consultas} (\textit{query engine}): provee a la aplicación de la funcionalidad de recuperación de información en base a consultas estructuradas.
\end{itemize}

A continuación se estudian con más detalle, ofreciendo ejemplos de los más utilizados y el caso concreto del proyecto que atañe a esta memoria.

\subsection{Almacén RDF (\textit{store})}

El almacén de ternas es un componente esencial para salvaguardar conjuntos de datos en ternas independientemente de su origen (un fichero serializado, el resultado de una consulta, etc.). Conceptualmente, el equivalente en una base de datos relacional sería una tabla con tres columnas (\textit{Sujeto - Predicado - Objeto}). Sin embargo, parece evidente que un almacén RDF esté optimizado para el almacenamiento y recuperación de ternas RDF.

Comparados con una base de datos relacional, sin embargo, son más flexibles y requieren de menor coste de uso y mantenimiento. Más concretamente:

\begin{itemize}  
	\item \textbf{Flexibilidad:} su esquema flexible permite realizar cambios sin paradas ni rediseños, cosa que no ocurre con una base de datos relacional.
	\item \textbf{Estandarización:} el nivel de estandarización de RDF y SPARQL es mucho mayor que el de SQL. Es prácticamente inmediato sustituir un almacén de tripletas por otro, mientras que en el caso de las bases de datos relacionales es necesario tener en cuenta los distintos dialectos e implementaciones de SQL según el fabricante.
	\item \textbf{Expresividad:} es mucho más sencillo modelar datos complejos y con elevado número de relaciones entre ellos en RDF que en SQL. Ocurre al contrario si los datos son de naturaleza tabular, naturalmente.
\end{itemize}

No todo son ventajas en la comparación:

\begin{itemize}  
	\item \textbf{Madurez:} las bases de datos relacionales son mucho más maduras y presentan más funcionalidades que los almacenes de ternas.
	\item \textbf{Coste de almacenamiento:} El coste por unidad de información almacenada en un almacén de ternas es mucho mayor que el de una base de datos relacional, lo cual puede ser crítico si se están tratando grandes volúmenes de datos.
\end{itemize}

Entre los almacenes de ternas más utilizados, se pueden citar OpenLink Virtuoso\footnote{\url{https://virtuoso.openlinksw.com/}}, GraphDB de Ontotext\footnote{\url{https://ontotext.com/products/graphdb/}}, Apache Jena TDB\footnote{\url{https://jena.apache.org/documentation/tdb/}} o AllegroGraph\footnote{\url{https://franz.com/agraph/allegrograph/}}.


\subsubsection{Almacén en el proyecto}

En el caso del presente proyecto, se valoraron dos alternativas:

\begin{itemize}  
	\item \textbf{RDF-Ext Dataset\footnote{\url{https://github.com/rdf-ext/rdf-store-dataset}}} un simple conjunto de datos cargado en memoria y conforme con la especificación estándar. Este almacén presentaba limitaciones en cuanto a rendimiento y número de tripletas a almacenar, además de estar pensado para operaciones síncronas.
	\item \textbf{N3.js:\footnote{\url{https://github.com/rdfjs/N3.js/}}} La bilioteca N3 ofrece, además de almacenamiento de tripletas en memoria en \textit{Javascript} nativo, facilidades de serialización y procesado con formatos estándar como Turtle, N3, N-Triples y TriG. Si bien su conformidad con la especificación de interfaces RDF.js no es completa, sí está presente en gran parte de sus módulos (\textit{DataFactory, StreamParser, StreamWriter y Store}).
\end{itemize}

Confirmadas las limitaciones de RDF-Ext Dataset y consultado con el \textit{W3C RDFJS Community Group}, se opta finalmente por utilizar \textbf{N3.js} (lo que supuso adaptar ligeramente la implementación del proyecto al nuevo \textit{storage}).


\subsection{Procesador y Serializador RDF (\textit{parser/serializer})}

En muchos casos, los módulos para importación y exportación de datos en RDF son proporcionados por el propio almacén. Sin entrar a valorar su sintaxis dada su complejidad específica y por considerarse fuera del interés de este proyecto, sí se va a proceder a identificar y caracterizar los formatos de serialización más comunes.

\subsubsection{RDF/XML}

Se trata de una representación en XML, comúnmente criticada por su dificultad de lectura por parte de personas. Entre sus otras críticas están las limitaciones impuestas por las reglas de nomenclatura de XML o los problemas encontrados para procesar este formato con herramientas populares para XML\cite{ducharme01}. Para poder codificar un grafo RDF en XML, tanto los nodos como los predicados han de ser representados en términos de XML (elementos, atributos, contenido de elementos y valores de atributos). 

Conceptualmente, se construye a partir de un conjunto de descripciones más pequeñas, cada una de las cuales traza un camino a lo largo de un grafo RDF. Estos caminos se describen en términos de los nodos (sujetos) y enlaces (predicados), que los conectan con otros nodos (objetos).

A continuación se muestra un ejemplo de serialización en RDF/XML\footnote{\url{https://www.w3.org/TR/rdf-syntax-grammar/\#example3}}:

\begin{lstlisting}[basicstyle=\tiny, language=XML, caption={Ejemplo de RDF/XML del W3C.},captionpos=b]

<rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
<ex:editor>
<rdf:Description>
<ex:homePage>
<rdf:Description rdf:about="http://purl.org/net/dajobe/">
</rdf:Description>
</ex:homePage>
</rdf:Description>
</ex:editor>
</rdf:Description>

<rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
<ex:editor>
<rdf:Description>
<ex:fullName>Dave Beckett</ex:fullName>
</rdf:Description>
</ex:editor>
</rdf:Description>

<rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar">
<dc:title>RDF 1.1 XML Syntax</dc:title>
</rdf:Description>

\end{lstlisting}

\subsubsection{N-Triples}

Se trata de una notación muy simple pero verbosa, donde cada línea representa una única declaración conteniendo sujeto, predicado y objeto seguidos por un punto.

Ejemplo\footnote{\url{https://www.w3.org/TR/n-triples/}}:

\begin{lstlisting}[basicstyle=\tiny, language=XML, caption={Ejemplo de N-Triples del W3C.},captionpos=b]

<http://example.org/#spiderman> <http://www.perceive.net/schemas/relationship/enemyOf> <http://example.org/#green-goblin> .

\end{lstlisting}

\subsubsection{N3}

N3, abreviatura de \textit{Notation 3}, fue un proyecto personal de Tim Berners-Lee\cite{ducharme01}. Es muy similar a N-Triples, pero añadiendo características adicionales como atajos, un formato más claro, o la condensación de muchas de las repeticiones de este formato.

A pesar de todo, N3 nunca se convirtió en un estándar y sus características adicionales frente a N-Triples no tuvieron mucha aceptación.

\subsubsection{Turtle}

El formato Turtle permite escribir un grafo RDF en texto de una forma más compacta que RDF/XML y más sencilla de leer que N-Triples. Su gramática es un subconjunto de la especificación del lenguaje de consulta SPARQL 1.1, compartiendo ambas nombres de terminales y producciones en la medida de lo posible.

En estos momentos, es el formato de serialización más popular entre las comunidades de desarrolladores\cite{yu01}.

A continuación se muestra un ejemplo de serialización en Turtle\footnote{https://www.w3.org/TR/turtle/}:

\begin{lstlisting}[basicstyle=\tiny, language=XML, caption={Ejemplo de Turtle del W3C.},captionpos=b]

@base <http://example.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix rel: <http://www.perceive.net/schemas/relationship/> .

<#green-goblin>
rel:enemyOf <#spiderman> ;
a foaf:Person ;    # in the context of the Marvel universe
foaf:name "Green Goblin" .

<#spiderman>
rel:enemyOf <#green-goblin> ;
a foaf:Person ;
foaf:name "Spiderman" .

\end{lstlisting}

\subsubsection{Procesadores y serializadores en el proyecto}

El almacén seleccionado, \textbf{N3.js, proporciona procesadores y serializadores} para los principales formatos citados: N3, N-Triples, Turtle y TriG (una extensión de este último).

No se ha considerado necesario diseñar ningún serializador o procesador personalizado, al estar ya incluidos los formatos más comunes utilizados por desarrolladores (nótese la ausencia deliberada de RDF/XML).


\subsection{Motor de consulta RDF (\textit{query engine})}

El motor de consulta es un componente íntimamente ligado al almacén de ternas. El W3C fijó un estándar para consultas: SPARQL (presentado en \ref{sec:sparql}), cuya especificación está en su versión 1.1 desde 2013.

Desde el punto de vista de la arquitectura de una aplicación semántica, es deseable que el motor de consultas, además de cumplir con la especificación, esté íntimamente integrado con el almacén de ternas para ofrecer un rendimiento aceptable.

Los principales proveedores de almacenes de ternas ofrecen también motores de consulta integrados, como Apache Jena, Virtuoso, AllegroGraph...


\subsubsection{Motor de consultas en el proyecto}\label{sec:motor-de-consultas-en-el-proyecto}

En el caso del presente proyecto, integrar un motor de consultas no fue sencillo. El componente N3.js no ofrece dichas funcionalidades, con lo que fue necesario estudiar la viabilidad de incorporar un motor local totalmente desarrollado en \textit{Javascript}.

Tras el estudio de los trabajos previos desarrollados (\ref{subsec:consulta}) y la  situación actual (\ref{subsubsec:manejosparql}), se llegó a la conclusión de que la plataforma Comunica se posicionaba como el producto abierto más prometedor para satisfacer las necesidades de consulta SPARQL.

Comunica proporciona las herramientas necesarias para crear una aplicación combinando múltiples bloques de construcción independientes. Su propósito es ofrecer una implementación modular de un cliente \textit{Triple Pattern Fragment} o\textit{ Linked Data Fragment}\footnote{\url{http://linkeddatafragments.org/in-depth/\#tpf}}, un tipo de fragmento que consiste en:

\begin{itemize}  
	\item \textbf{Datos} que corresponden a un patrón de tripleta.
	\item \textbf{Metadatos} que consisten en el total aproximado de tripletas.
	\item \textbf{Controles} que llevan al resto de fragmentos del mismo conjunto de datos.
\end{itemize}

De forma resumida, un cliente que soporta este tipo de fragmentos puede resolver múltiples consultas SPARQL de forma eficiente.

Comunica consta de los siguientes componentes:

\begin{itemize}  
	\item \textbf{Actores:} definen el formato de la entrada que aceptan y la salida correspondiente que producen.
	\item \textbf{Buses:} combinan los actores que soportan el mismo formato de entrada y salida y permite enviar mensajes a todos los actores registrados en un bus dado.
	\item \textbf{Mediadores:} envuelven los buses y se aseguran de que cada petición recibe tan sólo una respuesta.
\end{itemize}

\begin{figure}[h]
	\centering
	\includesvg[width = 500pt]{actor-mediator-bus}
	\caption{Arquitectura de Comunica. Fuente: Web de documentación de Comunica.}
\end{figure}

Para el presente proyecto, han sido necesarios dos actores:

\begin{itemize}  
	\item \textbf{actor-init-sparql:} se trata de un cliente que permite resolver consultas sobre interfaces heterogéneos. En concreto, este módulo inicializa un motor Comunica con actores que evalúan consultas SPARQL.
	\item \textbf{actor-init-sparql-rdfjs:} permite lanzar consultas SPARQL a fuentes que implementan la interfaz \textit{Source}\footnote{\url{http://rdf.js.org/\#source-interface}}. Una de esas fuentes es N3.js, el \textit{store} utilizado para almacenar ternas en el proyecto.
\end{itemize}

Es decir, se utiliza un módulo para lanzar consultas a \textit{endpoints} SPARQL remotos y otro para la fuente o almacén local. Estos módulos \textbf{aún están en desarrollo y no han alcanzado una versión estable} a fecha de redacción de la presente memoria, con lo que se van adquiriendo nuevas funcionalidades y corrigiendo defectos a lo largo del tiempo de desarrollo de este proyecto (por ejemplo, en Julio de 2018 el motor de consulta no soportaba la palabra clave SERVICE, característica implementada en Agosto).

\section{Arquitectura de la aplicación Vue}

Al margen de su naturaleza semántica, la herramienta desarrollada se implementa en \textit{Javascript ES6+} y Vue.js. Es necesario, por tanto, proponer un diseño de alto nivel de sus componentes.

\subsection{Almacenamiento de estado}

Para almacenar el estado de la aplicación se ha optado por usar Vuex\footnote{\url{https://vuex.vuejs.org/}}. 

Vuex es una biblioteca que implementa un patrón de gestión de estado (ver figura \ref{fig:vuex}\cite{vuex01}) basado en Redux\footnote{Redux es un contenedor predecible del estado de aplicaciones Javascript. Ver \url{https://es.redux.js.org/}}, Flux\footnote{Una arquitectura de aplicación para React que utiliza un flujo de datos unidireccional. Ver \url{https://github.com/facebook/flux}} y la arquitectura Elm\footnote{Un patrón sencillo de arquitectura de aplicaciones web. Ver \url{https://guide.elm-lang.org/architecture/}}. Se utiliza como un almacén centralizado para todos los componentes de la aplicación, y permite asegurar:

\begin{itemize}  
	\item Que todos los componentes comparten ese estado.
	\item Que el estado sólo podrá ser modificado de forma controlada, bien síncrona o asíncrona.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{vuex}
	\caption{Vuex: gestión de estado centralizado.}
	\label{fig:vuex}
\end{figure}

Sin entrar en detalles, el funcionamiento de Vuex se ciñe a las siguientes reglas:

\begin{itemize}  
	\item Existe un único estado compartido por todos los componentes de la aplicación, independientemente de que cada componente tenga su propio estado individual.
	\item El acceso al estado centralizado se realiza a través de \textbf{getters}.
	\item El estado sólo puede ser modificado a través de \textbf{mutaciones síncronas}.
	\item Las mutaciones pueden ser ejecutadas de manera asíncrona a través de \textbf{acciones}.
\end{itemize}

El estado de la aplicación puede resumirse con las entidades mostradas en el cuadro \ref{tab:estado}. Por otra parte, se han definido las acciones y mutaciones necesarias para modificar dicho estado. En el cuadro \ref{tab:actions} se resumen las acciones a implementar con la funcionalidad requerida (no se incluyen las mutaciones por considerarse que no aportan nada en cuanto a diseño que no aporten ya las acciones).

Es interesante también enumerar los \textit{getters} (ver cuadro \ref{tab:getters}), o métodos de consulta que permiten extraer información del estado de la aplicación sin acceder directamente a sus estructuras de datos.

\begin{table}
	\centering
	\begin{tabular}{p{3cm}p{10cm}}
		\toprule
		Estado & Descripción \\ \midrule
		Bloques de construcción RDF &  Contiene los bloques más comunes utilizados para modelar un dominio de información en RDF (ej: clases, propiedades, etc.) \\ \midrule
		Almacén de ternas &  Estructura de datos de tipo almacén que albergará las ternas que componen el grafo. \\ \midrule
		Actividad &  Contiene el contenido de la actividad académica a realizar. \\ \midrule
		Prefijos & Contiene los prefijos más comunes utilizados para precargar en las consultas SPARQL. \\ \midrule
		Vocabularios &  Contiene las definiciones y URLs de los vocabularios más comunes para posibilitar su descarga al grafo en el módulo correspondiente. \\
		\bottomrule
	\end{tabular}
	\caption{Estado de la aplicación.}
	\label{tab:estado}
\end{table}

	\begin{table}
	\centering
	\begin{tabular}{p{2cm}p{11cm}}
		\toprule
		ID & Getter \\ \midrule
		GET-1 & Recuperar listado de sujetos por predicado y objeto. \\ \midrule
		GET-2 & Recuperar listado de sujetos por predicado. \\ \midrule
		GET-3 & Recuperar listado de objetos por predicado y sujeto. \\ \midrule
		GET-4 & Recuperar listado de ternas cuyo sujeto coincide con uno dado. \\ \midrule
		GET-5 & Recuperar listado de ternas cuyo objeto coincide con uno dado. \\ \midrule
		GET-6 & Recuperar todas las ternas del almacén. \\ \midrule
		GET-7 & Recuperar un listado de las propiedades cargadas por defecto para el modelado. \\
		\bottomrule
	\end{tabular}
	\caption{Listado de \textit{getters} que recuperan el estado de la aplicación.}
	\label{tab:getters}
\end{table}


	\begin{table}
	\centering
	\begin{tabular}{p{2cm}p{3cm}p{11cm}}
		\toprule
		ID & Acción & Responsabilidad \\ \midrule
		ACC-1 & Añadir terna &  Añade una terna al grafo pasando como parámetros su sujeto, predicado y objeto. \\ \midrule
		ACC-2 & Eliminar recurso & Elimina todas las ternas que tengan un determinado recurso en cualquiera de sus posibles posiciones (sujeto, predicado, objeto). \\ \midrule
		ACC-3 & Editar recurso &  Modifica la definición de un recurso en todas las ternas que lo tengan en cualquiera de sus posibles posiciones (sujeto, predicado, objeto). \\ \midrule
		ACC-4 & Eliminar terna & Elimina una terna del grafo pasando como parámetros su sujeto, predicado y objeto. \\ \midrule
		ACC-5 & Editar literal &  Modifica la definición de un literal o cadena de texto utilizado como objeto en una propiedad. \\ \midrule
		ACC-6 & Añadir literal &  Añade una terna con un literal o cadena de texto como objeto. \\ \midrule
		ACC-7 & Importar N3 & Importa un grafo en formato N3, Turtle, TriG o N-Triples. \\ \midrule
		ACC-8 & Añadir N3 &  Añade al grafo existente otro en formato N3, Turtle, TriG o N-Triples. \\ \midrule
		ACC-9 & Eliminar N3 & Elimina del grafo local las ternas existentes en otro grafo en formato N3, Turtle, TriG o N-Triples \\ \midrule
		ACC-10 & Cargar actividad & Carga el contenido de una actividad en formato Markdown. \\ \midrule
		ACC-11 & Exportar a JSON-LD &  Exporta el grafo local a un archivo en formato JSON-LD. \\ \midrule
		ACC-12 & Exportar a Turtle &  Exporta el grafo local a un archivo en formato Turtle. \\ \midrule
		ACC-13 & Modificar estado de un vocabulario & Activa o desactiva uno de los vocabularios precargados. \\
		\bottomrule
	\end{tabular}
	\caption{Listado de \textit{actions} que modifican el estado de la aplicación.}
	\label{tab:actions}
\end{table}

 \hspace{2em}
 
\subsection{Arquitectura de módulos}\label{sec:arquitectura-de-módulos}

En el cuadro \ref{tab:modulos} se plantea el desglose de la aplicación en módulos independientes que dan respuesta a las necesidades expuestas.

\begin{table}
	\centering
	\begin{tabular}{p{2cm}p{3cm}p{3cm}p{5cm}}
		\toprule
		ID & Módulo & Necesidades & Casos de uso \\ \midrule
		MOD-1 & Actividades & 7 & \ref{sec:cargar-una-actividad} \\ \midrule
		MOD-2 & Vocabularios & 10 & \ref{sec:cargar-un-vocabulario}, \ref{sec:des-cargar-un-vocabulario} \\ \midrule
		MOD-3 & Importar/exportar &  8, 9 & \ref{sec:importar-grafo}, \ref{sec:anadir-a-grafo}, \ref{sec:exportar-grafo} \\ \midrule
		MOD-4 & Modelado & 1, 2 & \ref{sec:dar-de-alta-una-nueva-clase}, \ref{sec:editar-una-clase-existente}, \ref{sec:eliminar-una-clase-existente}, \ref{sec:dar-de-alta-una-nueva-anotacion-o-propiedad-estandar-de-una-clase}, \ref{sec:editar-una-propiedad-o-anotacion-de-una-clase}, \ref{sec:eliminar-una-propiedad-o-anotacion-de-una-clase} \\ \midrule
		MOD-5 & Poblamiento & 3 & \ref{sec:poblar-el-grafo-con-una-tripleta} \\ \midrule
		MOD-6 & Consulta &  4, 5, 6 & \ref{sec:lanzar-consulta-a-grafo-local}, \ref{sec:lanzar-consulta-a-grafo-remoto} \\ 
		\bottomrule
	\end{tabular}
	\caption{Matriz de trazabilidad de módulos, requisitos y necesidades.}
	\label{tab:modulos}
\end{table}


\subsection{Arquitectura de componentes}\label{sec:arquitectura-de-componentes}

Para poder dar cumplimiento a los requisitos de la aplicación, se definen en el cuadro \ref{tab:componentes} los componentes necesarios con sus ámbitos de responsabilidad.


	\begin{table}
		\centering
		\begin{tabular}{p{2cm}p{3cm}p{10cm}}
			\toprule
			ID & Componente & Responsabilidad \\ \midrule
			COMP-1 & Contenedor de aplicación &  Estructura básica de la aplicación (cabecera, pie, barra lateral). \\ \midrule
			COMP-2 & Bienvenida &  Entrada a la aplicación con ayuda y descripción general. \\ \midrule
			COMP-3 & Contenedor de modelo &  Contiene los componentes de edición del modelo.\\ \midrule
			COMP-4 & Contenedor de importación/exportación & Contiene los componentes de importación y exportación de datos. \\ \midrule
			COMP-5 & Contenedor de consultas SPARQL &  Contiene los componentes de ejecución y visualización de resultados de consultas SPARQL. \\ \midrule
			COMP-6 & Contenedor de actividades &  Contiene los componentes de carga y visualización de actividades. \\ \midrule
			COMP-7 & Listado de recursos &  Componente reutilizable para listar recursos en una tabla de datos. \\ \midrule
			COMP-8 & Detalle de recursos &  Componente reutilizable para visualizar detalles de recursos. \\ \midrule
			COMP-9 & Lanzador de consultas SPARQL & Componente reutilizable para lanzar consultas SPARQL \\ \midrule
			COMP-10 & Listado de resultados de consultas SPARQL & Componente reutilizable para mostrar resultados de una consulta SPARQL.\\ \midrule
			COMP-11 & Cargador de archivos &  Componente reutilizable para importar datos desde archivo. \\ \midrule
			COMP-12 & Cargador de URLs &  Componente reutilizable para importar datos desde URL. \\ \midrule
			COMP-13 & Cargador de Vocabularios & Componente reutilizable para habilitar o deshabilitar vocabularios. \\ \midrule
			COMP-14 & Visor de markdown & Componente reutilizable para visualizar markdown renderizado en HTML. \\ 
			\bottomrule
		\end{tabular}
		\caption{Listado de componentes de la aplicación.}
		\label{tab:componentes}
	\end{table}


En la figura \ref{fig:componentes} se muestra un diagrama UML 2.0 con la jerarquía de componentes de la aplicación, que muestra convenientemente las relaciones entre los mismos distinguiéndose tres niveles:

\begin{itemize}
	\item Componente raíz de la aplicación, del que dependen todos los demás (actúa de enrutador).
	\item Componentes intermedios o contenedores, no reutilizables.
	\item Componentes finales reutilizables.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{componentes}
	\caption{Jerarquía de componentes de la aplicación.}\label{fig:componentes}
\end{figure}