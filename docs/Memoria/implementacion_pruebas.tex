\chapter{Implementación y pruebas}

\section{Implementación}

\subsection{Estándar Javascript}

Desde su nacimiento en 1995 de la mano de Netscape como lenguaje de \textit{scripting} para mejorar la experiencia final del usuario de Internet a través de un navegador, Javascript ha evolucionado hasta convertirse en la tecnología dominante en el desarrollo de frontend web. 

Es importante describir dicha evolución a través de sus distintos estándares (ECMAScript) para contextualizar el presente desarrollo:

	\begin{itemize}
	\item ES5, publicado en 2009 y soportado por la práctica totalidad de los navegadores (incluidos los antiguos).
	\item ES2015, también conocido como ES6,fue la primera de una serie de revisiones del estándar con carácter anual, después de varios años transcurridos desde el estándar anterior. Se trata de una versión rompedora con los estándares anteriores, que incorpora importantes novedades de sintaxis.
	\item ES2016 y posteriores, que van incorporando más mejoras como la gestión de eventos asíncronos con \textit{async/await}.
\end{itemize}

Aunque los navegadores están haciendo grandes progresos con su compatibilidad total con ES6, aún no es recomendable utilizarlo en forma nativa. Para resolver este problema surgen los transpiladores o \textit{transpilers} como Babel\footnote{\url{https://babeljs.io/}} (utilizado en este proyecto), que traducen el lenguaje programado en un estándar más moderno como ES2015+ a ``Vanilla ES5'', de tal manera que el código pueda ser ejecutado en cualquier navegador.

A la vista de lo expuesto, se plantea la implementación de la presente aplicación en ES6+ (es decir, ES6 y posteriores), pero efectuando un \textit{transpiling} a ES5 para minimizar cualquier problema de compatibilidad con los distintos navegadores.

\subsection{Entorno}

Hoy en día, no es posible hablar de desarrollo profesional y moderno en Javascript sin hablar de Node.js\footnote{\url{https://nodejs.org}}. Node.js es un entorno de ejecución para Javascript construido con el motor V8 de Chrome\footnote{El motor de alto rendimiento de Google para Javascript escrito en C++. Ver \url{https://developers.google.com/v8/}} y orientado a eventos asíncronos. Está diseñado para construir aplicaciones de red escalables. Introdujo un sistema de módulos que ha sido la base de la reutilización de bibliotecas de código en Javascript a través del repositorio npm\footnote{https://docs.npmjs.com/getting-started/what-is-npm}, con en torno a 600.000 paquetes de código abierto disponibles para la comunidad de desarrolladores.

En la implementación de esta aplicación se han utilizado las siguientes versiones de estos componentes, cuya instalación previa es necesaria para la construcción y ejecución de la misma:

	\begin{itemize}
	\item Node.js 10.7.0
	\item npm 6.1.0

\end{itemize}

Tanto Node como npm pueden descargarse e instalarse en múltiples sistemas operativos desde sus respectivas páginas web.

\subsection{Estructura del proyecto}

El proyecto presenta la siguiente estructura jerárquica de directorios:

\begin{itemize}
	\item \textbf{build}: contiene los archivos de configuración de Webpack, tanto para el servidor de desarrollo como para el entorno de producción.
	\item \textbf{config}: contiene los archivos de configuración del proyecto por entorno (dev, test, pro). Si bien no es conveniente modificarlo, para la presente aplicación tuvo que añadirse el soporte para babel-polyfill para permitir la correcta ejecución de determinados paquetes en todos los navegadores.
	\item \textbf{dist}: contiene los archivos que deberán ser desplegados en la plataforma de producción (por ejemplo, Firebase).
	\item \textbf{docs}: notas del proyecto en markdown y código fuente en \LaTeX de esta memoria.
	\item \textbf{node\_modules}: contiene todos los paquetes y dependencias de npm necesarios para ejecutar el proyecto.
	\item \textbf{src}: contiene el código fuente de la aplicación y está estructurado, a su vez, de la siguiente forma:
	\begin{itemize}
		\item \textbf{components}: contiene los distintos componentes de la aplicación, siendo App.vue el principal.
		\item \textbf{fonts}: contiene las fuentes necesarias para visualizar correctamente Material Design.
		\item \textbf{router}: contiene la configuración de vue-router, un enrutador para Vue.js.
		\item \textbf{services}: contiene la configuración única de servicios para recuperar información de APIs REST a trabés dfe bibliotecas como axios\footnote{Un cliente HTTP basado en promesas para Node.js. Ver \url{https://github.com/axios/axios}}
		\item \textbf{store}: contiene la lógica necesaria para mantener el estado único de la aplicación a trabés de Vuex (ficheros de acciones, mutaciones, getters y el propio almacén.)
		\item \textbf{utils}: contiene utilidades o información por defecto necesaria para el correcto funcionamiento de la aplicación.
	\end{itemize}
	\item \textbf{static}: recursos estáticos que son copiados directamente.
	\item \textbf{test}: contiene la configuración y especificaciones de las pruebas unitarias y extremo a extremo.
	
\end{itemize}

Además, en el directorio raíz de la estructura del proyecto se pueden encontrar, entre otros, los siguientes archivos de configuración relevantes:

\begin{itemize}
	\item \textbf{.babelrc}: configuración del \textit{transpiler} Babel.
	\item \textbf{.gitignore}: archivos de proyecto que no deberán subirse al repositorio (binarios, temporales, etc.)
	\item \textbf{.eslintrc.js}: configuración del analizador estático de estilo y sintaxis ESlint.
	\item \textbf{package.json}: contiene la configuración de la tarea de construcción y la especificación de dependencias del proyecto.
	\item \textbf{.firebaserc}: configuración de proyecto de Firebase
	\item \textbf{firebase.json}: configuración de despliegue en Firebase (ver subsección \ref{sec:despliegue-del-proyecto}).
	
\end{itemize}

\subsection{Construcción del proyecto}

El proyecto de trabajo se ha generado usando la herramienta vue-cli\footnote{\url{https://cli.vuejs.org/}} en su versión 2 (durante el tiempo de desarrollo de este proyecto se publicó la versión 3). Esta herramienta permite generar proyectos configurados a partir de una plantilla y selección de parámetros. En concreto, se utilizó una plantilla propuesta por Vuetify\footnote{\url{https://vuetifyjs.com}}, una biblioteca de componentes de interfaz de usuario basada en Material Design\footnote{Un sistema de diseño para desarrollar interfaces de usuario impulsado por Google. Ver \url{https://material.io/}} para Vue. Se eligió esta biblioteca por ser una de las más usadas entre la comunidad de usuarios, disponer de un amplio catálogo de componentes implementados y presentar líneas de trabajo prometedoras para finales de este año (con la previsión de publicación de nuevos componentes y de mejora de los actuales).

La propia web de Vuetify presenta un asistente para elegir la plantilla más adecuada basándose en diversos parámetros introducidos por el usuario, tales como: experiencia con Vue, tipo de interfaz (web, móvil, escritorio), necesidad o no de generar estructuras de pruebas unitarias, etc. Dadas las necesidades de este proyecto, se optó por elegir una plantilla para programadores con poca experiencia en Vue, para la web y con estructuras de pruebas unitarias (y no con posicionamiento web). 

El resultado fue la plantilla webpack\footnote{Webpack es un empaquetador de módulos para JS. Ver \url{https://github.com/vuetifyjs/webpack} y \url{https://webpack.js.org/}}, que presenta las siguientes características:

\begin{itemize}
	\item Desarrollo:
	\begin{itemize}
		\item Incluye Webpack y vue-loader para SFC (\textit{Single File Components})
		\item Recarga en caliente con preservación de estado
		\item Análisis estático de estilo con ESlint\footnote{\url{https://eslint.org/}} al guardar
	\end{itemize}
	\item Construcción:
		\begin{itemize}
		\item Minificación de JS con UglifyJS\footnote{\url{https://github.com/mishoo/UglifyJS}}
		\item Minificación de HTML con html-minifier
		\item Minificación de CSS con cssnano
		\item Compilación de recursos estáticos con hashes de versiones para cacheo eficiente
		\end{itemize}
	\item Pruebas:
		\begin{itemize}
		\item Soporte de ES2015+ en archivos de test
		\item Jest\footnote{\url{https://jestjs.io/}} como plataforma de testing
		\item End-to-end\footnote{Las pruebas end-to-end o extremo a extremo permiten verificar el flujo de trabajo completo de una aplicación web. Son más lentos que los unitarios y difíciles de depurar, pero comprueban la funcionalidad completa de la aplicación.} con Nightwatch\footnote{\url{http://nightwatchjs.org/}}.
	\end{itemize}
\end{itemize}

\subsection{Ejecución del proyecto}

De manera predeterminada, es posible ejecutar los siguientes comandos:

	\begin{itemize}
	\item \textbf{npm install}: instala todas las dependencias del proyecto.
	\item \textbf{npm run dev}: sirve el contenido con recarga en caliente a través del puerto 8080.
	\item \textbf{npm run build}: construye el proyecto para desplegar en producción (con compresión).
	\item \textbf{npm run build --report}: construye el proyecto para producción y visualiza el informe del analizador de empaquetado.
	\item \textbf{npm run unit}: ejecuta las pruebas unitarias.
	\item \textbf{npm run e2e}: ejecuta las pruebas end-to-end.
	\item \textbf{npm test}: ejecuta todas las pruebas.
	
\end{itemize}


\subsection{Despliegue del proyecto}\label{sec:despliegue-del-proyecto}

Para desplegar la aplicación a modo de demostración se ha optado por utilizar Firebase\footnote{\url{https://firebase.google.com/}}, una plataforma de desarrollo de Google, a modo de PaaS. Si bien Firebase provee de muchos servicios en la nube (como base de datos, autenticación, almacenamiento, etc.) para este proyecto tan solo ha sido necesario utilizar el servicio de hosting. Para ello, basta con incluir un par de sencillos ficheros de configuración con el siguiente contenido:

\begin{lstlisting}[caption={Configuración de Firebase},captionpos=b]

{
	"hosting": {
		"public": "./dist",
		"ignore": [
			"firebase.json",
			"**/.*",
			"**/node_modules/**"
		]
	}
}
\end{lstlisting} 

\begin{lstlisting}[caption={Configuración de proyecto en Firebase},captionpos=b]

{
	"projects": {
		"default": "unedtfg-198720"
	}
}
\end{lstlisting} 

El entorno de demostración del proyecto es accesible con conexión a Internet a través de la siguiente URL: \url{https://unedtfg-198720.firebaseapp.com/#/}


\subsection{Detalles de implementación relevantes}

Sin pretender entrar a fondo en los detalles de la implementación, que puede consultarse en el repositorio de código fuente del proyecto en: \url{https://github.com/predicador37/rdf-editor}, sí se ha considerado conveniente documentar determinadas decisiones:

	\begin{itemize}
	\item En el módulo de \textbf{modelado}, el listado de recursos se ha implementado mediante una tabla para permitir su paginado, debido a que el número de clases o propiedades puede ser elevado en un modelo más o menos complejo. Por otra parte, los detalles de anotaciones (propiedades de clase, por ejemplo) se han implementado con listas expandibles, lo que permite una visualización compacta sin necesidad de una tabla (ya que se estima que el número de estas anotaciones no será muy elevado).
	\item En el módulo de \textbf{vocabularios}, la selección de estos se ha implementado como un conjunto de interruptores o\textit{ switches on/off}. Esto le permite al usuario cargar o descargar los vocabularios de forma sencilla, como si de una configuración se tratase (tal es la idea).
	\item En el módulo de \textbf{poblamiento}, se tiene lo siguiente:
		\begin{itemize}
		\item El campo ``sujeto'' se implementa como una entrada de texto libre, puesto que lo más probable es que se trate de un individuo nuevo.
		\item Los campos ``predicado'' y ``objeto'' ofrecen un selector con autocompletado que permite la introducción de nuevos términos. De esta forma, el usuario puede aprovechar los términos ya introducidos en la aplicación (bien por defecto bien a través de otros medios) o añadir los suyos propios, si bien ha de tener prevista su definición en el grafo.
	\end{itemize}
\item En el módulo de actividades, la importación a Markdown se realiza mediante la biblioteca vue-markdown\footnote{https://github.com/miaolz123/vue-markdown}, que a su vez utiliza markdown-it\footnote{https://github.com/markdown-it/markdown-it}. Esta última biblioteca implementa un procesador del formato Markdown con buen rendimiento y conforme a la especificación CommonMark Spec 0.28\footnote{\url{https://spec.commonmark.org/}}, si bien añade extensiones de sintaxis (como tablas y tachados de Github Flavored Markdown\footnote{La sintaxis de Markdown propuesta por Github, que añade características como tablas, estilo de texto, etc. Ver \url{https://help.github.com/articles/basic-writing-and-formatting-syntax/\#styling-text}}) y otros aspectos.
	
\end{itemize}

\section{Pruebas}